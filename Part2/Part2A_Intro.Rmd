---
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: false
    toc_depth: 3
    fig_width: 5
vignette: >
  %\VignetteIndexEntry{Introduction to GenomicRanges}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding[utf8]{inputenc}  
---

# Introduction

## What is the Ranges infrastructure?

The Ranges framework of packages provide data structures and
algorithms for analyzing genomic data. This includes standard genomic
data containers like GRanges and SummarizedExperiment, optimized data
representations like Rle, and fast algorithms for computing overlaps,
finding nearest neighbors, summarizing ranges and metadata, etc.

## Why use the Ranges infrastructure?

Hundreds of Bioconductor packages operate on Ranges data structures,
enabling the construction of complex workflows integrating multiple
packages and data types. The API directly supports data analysis as
well the construction of new genomic software. Code evolves easily
from analysis script to generalized package extending the Bioconductor
ecosystem.

## *GRanges*: Genomic Ranges

```{r GRanges, echo = FALSE, fig.cap="An illustration of genomic ranges. GRanges represents a set genomic ranges in terms of the sequence name (typically the chromosome), start and end coordinates (as an IRanges object), and strand (either positive, negative, or unstranded). GRanges holds information about its universe of sequences (typically a genome) and an arbitrary set of metadata columns with information particular to the dataset.", out.width="\\textwidth"}
knitr::include_graphics("files/granges.pdf")
```

The central genomic data structure is the *GRanges* class, 
which represents a collection of genomic ranges
that each have a single start and end location on the genome. It can be
used to store the location of genomic features such as binding
sites, read alignments and transcripts. 

## Constructing a *GRanges* object from data.frame

If we have a data.frame containing scores on a set of genomic
ranges, we can call `makeGRangesFromDataFrame()` to promote the
data.frame to a GRanges, thus adding semantics, formal constraints,
and range-specific functionality. For example,

```{r}
suppressPackageStartupMessages({
 library(GenomicRanges)
})
```

```{r example-GRanges}
df <- data.frame(
    seqnames = rep(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
    start = c(101, 105, 125, 132, 134, 152, 153, 160, 166, 170),
    end = c(104, 120, 133, 132, 155, 154, 159, 166, 171, 190),
    strand = rep(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)),
    score = 1:10,
    GC = seq(1, 0, length=10),
    row.names = head(letters, 10))
gr <- makeGRangesFromDataFrame(df, keep.extra.columns=TRUE)
gr
```

creates a *GRanges* object with 10 genomic ranges.
The output of the *GRanges* `show()` method separates the
information into a left and right hand region that are separated by
`|` symbols. The genomic coordinates (seqnames, ranges, and strand)
are located on the left-hand side and the metadata columns (annotation)
are located on the right. For this example, the metadata is
comprised of `"score"` and `"GC"` information, but almost
anything can be stored in the metadata portion of a *GRanges*
object.

## Loading a *GRanges* object from a standard file format

We often obtain data on genomic ranges from standard track formats,
like BED. The rtracklayer package parses those files directly into GRanges 
objects. The GenomicAlignments package parses
BAM files into GAlignments objects, which behave much like GRanges,
and it is easy to convert a GAlignments to a GRanges. We will see some
examples of loading data from files later in the tutorial.

